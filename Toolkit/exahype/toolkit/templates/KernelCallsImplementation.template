// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
#include <sstream>
#include <ostream>
#include <memory>
#include <array>
#include <unistd.h> // POSIX pipes
#include <stdio.h>
#include <string>
{% if strictJSON %}
#include <fstream> // read file
#include <streambuf> // read file
{% endif %}

#include "tarch/parallel/Node.h"

#include "exahype/plotters/Plotter.h"
#include "exahype/profilers/ProfilerFactory.h"
#include "exahype/solvers/Solver.h"
#include "exahype/solvers/SolverCoupling.h"
#include "kernels/KernelCalls.h"

#include "kernels/GaussLegendreQuadrature.h"
#include "kernels/GaussLobattoQuadrature.h"
#include "kernels/LimiterProjectionMatrices.h"
#include "kernels/DGMatrices.h"
#include "kernels/DGBasisFunctions.h"
#include "buildinfo.h"

{% for codegenContext in codegeneratorContextsList %}
#include "{{codegenContext.pathToOptKernel}}/Quadrature.h"
#include "{{codegenContext.pathToOptKernel}}/DGMatrices.h"
{% endfor %}

{% for solver in solvers %}
// includes for solver '{{solver.solver}}'
#include "{{solver.solver}}.h"
{% for plotter in solver.plotters %}
#include "{{plotter.headerPath}}"
{% endfor %}
{% endfor %}


void kernels::registerSolvers(exahype::parser::Parser& parser) {
{% for solver in solvers %}
{%set solver_loop = loop %}
  // register solver '{{solver.solver}}' (type: '{{solver.type}}')
  {
{% if solver.type == "ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(
      new {{project}}::{{solver.solver}}(
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          0
      )
    );
{% elif solver.type == "Limiting-ADER-DG" %}
    exahype::solvers::RegisteredSolvers.push_back(
      new {{project}}::{{solver.solver}}(
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getMaximumMeshDepth({{loop.index0}}),
          parser.getHaloCells({{loop.index0}}),
          parser.getRegularisedFineGridLevels({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}}),
          parser.getDMPObservables({{loop.index0}}),
          parser.getDMPRelaxationParameter({{loop.index0}}),
          parser.getDMPDifferenceScaling({{loop.index0}})
      )
    );
{% elif solver.type == "Finite-Volumes" %}
    exahype::solvers::RegisteredSolvers.push_back(
      new {{project}}::{{solver.solver}}(
          parser.getMaximumMeshSize({{loop.index0}}),
          parser.getTimeStepping({{loop.index0}})
      )
    );
{% endif %}
    parser.checkSolverConsistency({{loop.index0}});
    
{% for plotter in solver.plotters %}
    // register plotter '{{plotter.plotter}}'
{% if plotter.plotterType == "user::defined" %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, 
        new {{project}}::{{plotter.plotter}}()
      )
    );
{% else %}
    exahype::plotters::RegisteredPlotters.push_back( 
      new exahype::plotters::Plotter({{solver_loop.index0}},{{loop.index0}},parser, new {{project}}::{{plotter.plotter}}(
          *static_cast<{{project}}::{{solver.solver}}*>(exahype::solvers::RegisteredSolvers[{{solver_loop.index0}}])) 
      )
    );
{% endif %}
{% endfor %}
  }
{% endfor %}
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::initGaussLegendreNodesAndWeights(orders);
  kernels::initGaussLobattoNodesAndWeights(orders);
  kernels::initLimiterProjectionMatrices(orders);
  kernels::initDGMatrices(orders);
  kernels::initBasisFunctions(orders);
{% for codegenContext in codegeneratorContextsList %}
  {{codegenContext.namespace}}::initQuadratureNodesAndWeights();
  {{codegenContext.namespace}}::initDGMatrices();
{% endfor %}
}

void kernels::toString(std::ostream& ostream) {
  /* Generated solver registration code by the toolkit */
  ostream << "inputFileName:  {{specfileName}}\n";
  ostream << "projectName:    {{project}}\n";
{% for solver in solvers %}
  ostream << "Solver[{{loop.index0}}].type:             {{solver.type}}\n";
  ostream << "Solver[{{loop.index0}}].class:            {{solver.project}}::{{solver.solver}}\n";
{%   if solver.type=="Limiting-ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].class[ADERDG]:    {{solver.project}}::{{solver.ADERDGSolver}}\n";
  ostream << "Solver[{{loop.index0}}].abstract[ADERDG]: ";
  {{solver.project}}::{{solver.ADERDGSolver}}::constantsToString(ostream);
  ostream << "Solver[{{loop.index0}}].class[FV]:        {{solver.project}}::{{solver.FVSolver}}\n";
  ostream << "Solver[{{loop.index0}}].abstract[FV]: ";
  {{solver.project}}::{{solver.FVSolver}}::constantsToString(ostream);
{%   elif solver["type"]=="ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].abstract: ";
  {{solver.project}}::{{solver.solver}}::constantsToString(ostream);
{%   elif solver.type=="Finite-Volumes" %}
  ostream << "Solver[{{loop.index0}}].abstract: ";
  {{solver.project}}::{{solver.solver}}::constantsToString(ostream);
{%   endif %}
  ostream << "Solver[{{loop.index0}}].variables:           [ {{solver.variables_as_str}} ]\n";
  ostream << "Solver[{{loop.index0}}].material_parameters: [ {{solver.material_parameters_as_str}} ]\n";
  ostream << "Solver[{{loop.index0}}].global_observables:  [ {{solver.global_observables_as_str}} ]\n";
{# /* //TODO JMG
{%   if solver.type=="Limiting-ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].limiter:      [\n{% for item in solver["limiter"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
  ostream << "Solver[{{loop.index0}}].kernelADERDG: [\n{% for item in solver["aderdg_kernel"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
  ostream << "Solver[{{loop.index0}}].kernelFV:     [\n{% for item in solver["fv_kernel"].items() %}    {{item[0]}} : {{item[1]}}{% if not loop.last %},{% endif %}\n{% endfor %} ]\n";
{%   elif solver["type"]=="ADER-DG" %}
  ostream << "Solver[{{loop.index0}}].kernelADERDG: {{solver["aderdg_kernel"]}}\n";
{%   elif solver["type"]=="Finite-Volumes" %}
  ostream << "Solver[{{loop.index0}}].kernelFV: {{solver["fv_kernel"]}}\n";
{%   endif %}
*/ #}
{%   set solver_loop=loop %}
{%   for plotter in solver.plotters %}
  ostream << "Solver[{{solver_loop.index0}}].Plotter[{{loop.index0}}]: {{project}}::{{plotter.plotter}}(variables={{plotter.variables_as_str}})\n";
{%   endfor %}
{% endfor %}
 
// TODO not used yet
//  ostream << "\n";
//  ostream << "Kernel[0].hasConstants: true\n";
//  ostream << "Kernel[0].Plotter[0]: Euler::ErrorPlotter(variables=15)\n";
}

void kernels::finalise() {
  std::set<int> orders;
  for (const auto p : exahype::solvers::RegisteredSolvers) {
    orders.insert(p->getNodesPerCoordinateAxis()-1);
  }
  kernels::freeGaussLegendreNodesAndWeights(orders);
  kernels::freeGaussLobattoNodesAndWeights(orders);
  kernels::freeLimiterProjectionMatrices(orders);
  kernels::freeDGMatrices(orders);
  kernels::freeBasisFunctions(orders);
{% for codegenContext in codegeneratorContextsList %}
  {{codegenContext.namespace}}::freeQuadratureNodesAndWeights();
  {{codegenContext.namespace}}::freeDGMatrices();
{% endfor %}

  for (auto solver : exahype::solvers::RegisteredSolvers) {
    delete solver;
  }
  exahype::solvers::RegisteredSolvers.clear();

  for (auto plotter : exahype::plotters::RegisteredPlotters) {
    delete plotter;
  }
  exahype::plotters::RegisteredPlotters.clear();
  for (auto coupling : exahype::solvers::RegisteredSolverCouplings) {
    delete coupling;
  }
  exahype::solvers::RegisteredSolverCouplings.clear();
}

std::string kernels::readSpecificationFileToJSON(const std::string& filename) {
  static tarch::logging::Log _log("kernels");
{% if strictJSON %}
  if ( tarch::parallel::Node::getInstance().isGlobalMaster() ) {
    logInfo("readSpecificationFileToJSON()", "ExaHyPE was build with the strict JSON option (see toolkit options).");
    logInfo("readSpecificationFileToJSON()", "a valid JSON formatted specification file is expected.");
    logInfo("readSpecificationFileToJSON()", "read file: " << filename);
  }
  std::ifstream ifs(filename);
  std::string json((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
{% else %}
  // Call the ExaHyPE Python Toolkit and grab stdout. stderr instead passes.
  // Things where this could be improved:
  //  - Harmonize logging of subcommand into Tarch's logging
  //  - Pipe the specfile into the external parser instead of passing a filename
  constexpr int buffer_size = 512;
  
  // These variables are generated by the toolkit itself and should make it
  // safe to call a similar python environment as the toolkit has found it from
  // anywhere on the same computer/cluster. If you encounter problems, you
  // can change them here (note that KernelCalls.cpp is overwritten by every
  // toolkit run.
  std::string command = "{{externalParserCommand}} " + filename + " 2>&1";
  // Note that we pass stderr to stdout so in case of problems, 
  
  if ( tarch::parallel::Node::getInstance().isGlobalMaster() ) {
    logInfo("readSpecificationFileToJSON()", "Invoking external command: " << command);
  }

  std::array<char, buffer_size> buffer;
  std::string json;
  FILE* pipe = popen(command.c_str(), "r");
  if (!pipe) {
    logError("readSpecificationFileToJSON()", "Could not call external command with popen: " << strerror(errno) << " --- The command I tried to invoke  was: " << command);
    throw std::runtime_error("Could not call ExaHyPE toolkit.");
  }

  while (!feof(pipe))
    if (fgets(buffer.data(), buffer_size, pipe) != nullptr)
        json += buffer.data();

  // Check exist code of 
  int exit_status = pclose(pipe)/256; // the proper way is to use the WEXITSTATUS macro, but some Intel compilers on some clusters refuse to compile it.
  if(exit_status != 0) {
     logError("readSpecificationFileToJSON()", "The toolkit call from ExaHyPE returned a non-zero exit value ("<< exit_status <<"). That means it certainly did not produce proper JSON. The output is given below.");
     std::cerr << "Output from toolkit:\n" << json << "\n";
     throw std::runtime_error("Could not properly call toolkit from ExaHyPE.");
  }
{% endif %}

  return json;
}

const char* kernels::compiledSpecfile() {
  /* This is a hexdump of the specfile which was used to create this registration file.     */
  /* Run ExaHyPE with --help to learn how to view it's contents and/or run ExaHyPE with it. */
  static const char ret[] =
  {
    {{ specFileAsHex|wordwrap|indent }}
  };
  return ret;
}
