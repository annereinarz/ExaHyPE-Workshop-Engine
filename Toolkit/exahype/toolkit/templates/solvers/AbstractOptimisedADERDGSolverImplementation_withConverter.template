// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============


//**********************************
//**********************************
//***** USE ONLY FOR DEBUGGING *****
//**********************************
//**********************************

/*
  README
  ------
  
  This abstractsolver implementation uses the converter to be able to switch some optimised kernels
  with the generic ones. Just change the corresponding boolean hardcoded value in the corresponding
  method. By default uses the optimised code.
  
  This may help identify a faulty optimised kernel.
  
  This implementation is not always maintained and might be deprecated.

  Doesn't work with notimeavg
*/

#include "{{abstractSolver}}.h"
#include "{{optKernelPath}}/Kernels.h"
#include "{{optKernelPath}}/converter.h"

#include "kernels/aderdg/generic/Kernels.h"

#include "{{solver}}.h" // Have to include a proper declaration. Cannot use forward declared classes in static_cast.

#include <stdio.h>

// We define the constructor of the actual solver here in order to regenerate it easily.
{{project}}::{{solver}}::{{solver}}(double maximumMeshSize,int maximumMeshDepth,int DMPObservables,exahype::solvers::Solver::TimeStepping timeStepping {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler{% endif %}{% if hasConstants %}):
  {{abstractSolver}}::{{abstractSolver}}(maximumMeshSize,maximumMeshDepth,DMPObservables,timeStepping {% if enableProfiler %}, std::move(profiler) {% endif %}) {
}



{{project}}::{{abstractSolver}}::{{abstractSolver}}(double maximumMeshSize,int maximumMeshDepth,int DMPObservables,exahype::solvers::Solver::TimeStepping timeStepping {% if enableProfiler %}, std::unique_ptr<exahype::profilers::Profiler> profiler {% endif %} ):
  exahype::solvers::ADERDGSolver("{{solver}}",{{optNamespace}}::getNumberOfVariable(),{{optNamespace}}::getNumberOfParameter(),{{optNamespace}}::getBasisSize(),
                                 maximumMeshSize,maximumMeshDepth,DMPObservables,timeStepping {% if enableProfiler %}, std::move(profiler){% endif %}) {
}



void {{project}}::{{abstractSolver}}::constantsToString(std::ostream& os) {
	// This string is used in the --version output to identify compile time constants
	os << "{{project}}::{{abstractSolver}}("
	   << "nVar=" << NumberOfVariables << ", "
	   << "nParam=" << NumberOfParameters << ", "
	   << "nDim=" << Dimensions << ", "
	   << "order=" << Order
	   << ")";
}



void {{project}}::{{abstractSolver}}::spaceTimePredictor(double* const lQhbnd,double* const lFhbnd,double** const tempSpaceTimeUnknowns,double** const tempSpaceTimeFluxUnknowns,double* const tempUnknowns,double* const tempFluxUnknowns,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx,const double dt, double** const tempPointForceSources) {
{% if enableProfiler %}
  _profiler->start("spaceTimePredictor");
{% endif %}

  constexpr bool useGeneric = false;
  
if(useGeneric) {
  
#if DIMENSIONS==2
  double cellSize[2];
#else
  double cellSize[3];
  cellSize[2] = 1.0/inverseDx[2];
#endif
  cellSize[0] = 1.0/inverseDx[0];
  cellSize[1] = 1.0/inverseDx[1];
  
  double* lQhi = new double[{{optNamespace}}::converter::getQhiGenArraySize()];
  double* lFhi = new double[{{optNamespace}}::converter::getFhiGenArraySize()];
  double* Qbnd = new double[{{optNamespace}}::converter::getQhbndGenArraySize()];
  double* Fbnd = new double[{{optNamespace}}::converter::getFhbndGenArraySize()];
  {{optNamespace}}::converter::Qhi_optimised2generic(tempUnknowns, lQhi);
  {{optNamespace}}::converter::Fhi_optimised2generic(tempFluxUnknowns, lFhi);
  {{optNamespace}}::converter::Qhbnd_optimised2generic(lQhbnd, Qbnd);
  {{optNamespace}}::converter::Fhbnd_optimised2generic(lFhbnd, Fbnd);
  
{% if usePointSources %}
  double* pointForceSources_g[2];
  pointForceSources_g[0] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
  pointForceSources_g[1] = tempPointForceSources[1];
  {{optNamespace}}::converter::PSi_optimised2generic(tempPointForceSources[0],pointForceSources_g[0]);
{% else %}
  double** pointForceSources_g = nullptr;
{% endif %}
  
  
{% if  isLinear %}
  kernels::aderdg::generic::c::spaceTimePredictorLinear<{{usePointSources_s}}, {{useSource_s}}, {{useFlux_s}}, {{useNCP_s}}, {{useMaterialParameters}}, {{solver}}>(*static_cast<{{solver}}*>(this), Qbnd, Fbnd, tempSpaceTimeUnknowns, tempSpaceTimeFluxUnknowns, lQhi, lFhi, luh, &cellSize[0], dt, pointForceSources_g);
{% else %}
  kernels::aderdg::generic::c::spaceTimePredictorNonlinear<{{useSource_s}}, {{useFlux_s}}, {{useNCP_s}}, {{noTimeAveraging}}, {{solver}}>(*static_cast<{{solver}}*>(this), Qbnd, Fbnd, tempSpaceTimeUnknowns, tempSpaceTimeFluxUnknowns, lQhi, lFhi, luh, &cellSize[0], dt);
{% endif %}
  
  {{optNamespace}}::converter::Qhi_generic2optimised(lQhi, tempUnknowns);
  {{optNamespace}}::converter::Fhi_generic2optimised(lFhi, tempFluxUnknowns);
  {{optNamespace}}::converter::Qhbnd_generic2optimised(Qbnd, lQhbnd);
  {{optNamespace}}::converter::Fhbnd_generic2optimised(Fbnd, lFhbnd);
  
  delete[] lQhi;
  delete[] lFhi;
  delete[] Qbnd;
  delete[] Fbnd;
{% if usePointSources %}
  delete[] pointForceSources_g[0];
{% endif %}
    
    
} else {
  
{% if useFlux %}
{% if dimensions == 2 %}
  constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**nDim)*nVarPad
{% else %}
  constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**nDim)*nVarPad
{% endif %}
{% else %}
  constexpr int lSi_offset  = 0; //no Flux
  constexpr int lShi_offset = 0; //no Flux
{% endif %}

{% if  isLinear %}
  {{optNamespace}}::spaceTimePredictorLinear(*static_cast<{{solver}}*>(this), lQhbnd, lFhbnd, tempSpaceTimeUnknowns[0] /*lQi*/, tempSpaceTimeFluxUnknowns[0] /*lFi*/, &tempSpaceTimeFluxUnknowns[0][lSi_offset] /*lSi*/, tempUnknowns /*lQhi*/, tempFluxUnknowns /*lFhi*/, &tempFluxUnknowns[lShi_offset] /*lShi*/, tempSpaceTimeFluxUnknowns[1] /*gradQ*/, tempPointForceSources[0] /*PSi*/, tempPointForceSources[1] /*PSderivatives*/, luh, inverseDx, dt);
{% else %}
{% if noTimeAveraging %}
  //No Time Averaging scheme
  {{optNamespace}}::picardLoopNonlinear(*static_cast<{{solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], {% if useNCP %}tempSpaceTimeFluxUnknowns[1]{% else %}nullptr{% endif %}); //lSi, gradQ
  {{optNamespace}}::extrapolatorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], lQhbnd, lFhbnd);
{% else %}
  {{optNamespace}}::picardLoopNonlinear(*static_cast<{{solver}}*>(this), luh, dt, inverseDx, tempSpaceTimeUnknowns[0], tempSpaceTimeUnknowns[1], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], {% if useNCP %}tempSpaceTimeFluxUnknowns[1]{% else %}nullptr{% endif %}); //lSi, gradQ
  {{optNamespace}}::predictorNonlinear(tempSpaceTimeUnknowns[0], tempSpaceTimeFluxUnknowns[0], &tempSpaceTimeFluxUnknowns[0][lSi_offset], tempUnknowns, tempFluxUnknowns, &tempFluxUnknowns[lShi_offset]);
  {{optNamespace}}::extrapolatorNonlinear(tempUnknowns, tempFluxUnknowns, lQhbnd, lFhbnd);
{% endif %}
{% endif %}
  
}
  
{% if enableProfiler %}
  _profiler->stop("spaceTimePredictor");
{% endif %}
}



void {{project}}::{{abstractSolver}}::addUpdateToSolution(double* const luh,const double* const luhOld,const double* const lduh,const double dt) {
{% if enableProfiler %}
  _profiler->start("solutionUpdate");
{% endif %}
  {{optNamespace}}::solutionUpdate( luh, luhOld, lduh, dt );
{% if enableProfiler %}
  _profiler->stop("solutionUpdate");
{% endif %}
}



void {{project}}::{{abstractSolver}}::volumeIntegral(double* const lduh,const double* const lFi,const double* const lFhi,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{% if enableProfiler %}
  _profiler->start("volumeIntegral");
{% endif %}

  constexpr bool useGeneric = false;
  
if(useGeneric) {
  
#if DIMENSIONS==2
  double cellSize[2];
#else
  double cellSize[3];
  cellSize[2] = 1.0/inverseDx[2];
#endif
  cellSize[0] = 1.0/inverseDx[0];
  cellSize[1] = 1.0/inverseDx[1];
  
  double* lFhi_g = new double[{{optNamespace}}::converter::getFhiGenArraySize()];
  {{optNamespace}}::converter::Fhi_optimised2generic(lFhi, lFhi_g);
{% if isLinear %}
  kernels::aderdg::generic::c::volumeIntegralLinear<{{useSource_s}}, {{useFlux_s}}, NumberOfVariables, Order+1>(lduh,lFhi_g,&cellSize[0]);
{% else %}  
  kernels::aderdg::generic::c::volumeIntegralNonlinear<{{useSource_s}}, {{useFlux_s}}, {{noTimeAveraging}}, NumberOfVariables, Order+1>(lduh,nullptr,lFhi_g,&cellSize[0]);
{% endif %}

  delete[] lFhi_g;
    
    
} else {

{% if useFlux %}
{% if dimensions == 2 %}
  {% if noTimeAveraging %}
  constexpr int lSi_offset  = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  {% else %}
  constexpr int lShi_offset = 2*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
  {% endif %}
{% else %}
  {% if noTimeAveraging %}
  constexpr int lSi_offset  = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded(); //nDim*(nDof**(nDim+1))*nVarPad
  {% else %}
  constexpr int lShi_offset = 3*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getBasisSize()*{{optNamespace}}::getNumberOfVariablePadded();//nDim*(nDof**nDim)*nVarPad
  {% endif %}
{% endif %}
{% else %}
  constexpr int lSi_offset  = 0; //no Flux
  constexpr int lShi_offset = 0; //no Flux
{% endif %}

{% if noTimeAveraging %}
  //No Time Averaging scheme, lFhi == nullptr
  {{optNamespace}}::volumeIntegral( lduh, lFi, &lFi[lSi_offset], inverseDx );
{% else %}
  //Time averaging scheme, lFi not required
  {{optNamespace}}::volumeIntegral( lduh, lFhi, &lFhi[lShi_offset], inverseDx );
{% endif %}

}

{% if enableProfiler %}
  _profiler->stop("volumeIntegral");
{% endif %}
}



void {{project}}::{{abstractSolver}}::surfaceIntegral(double* const lduh,const double* const lFhbnd,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{% if enableProfiler %}
  _profiler->start("surfaceIntegral");
{% endif %}

  constexpr bool useGeneric = false;
  
if(useGeneric) {
  
#if DIMENSIONS==2
  double cellSize[2];
#else
  double cellSize[3];
  cellSize[2] = 1.0/inverseDx[2];
#endif
  cellSize[0] = 1.0/inverseDx[0];
  cellSize[1] = 1.0/inverseDx[1];
  
  double* lFhbnd_g = new double[{{optNamespace}}::converter::getFhbndGenArraySize()];
  {{optNamespace}}::converter::Fhbnd_optimised2generic(lFhbnd, lFhbnd_g);
{% if isLinear %}
  kernels::aderdg::generic::c::surfaceIntegralLinear<NumberOfVariables, Order+1>(lduh,lFhbnd_g,&cellSize[0]);
{% else %}
  kernels::aderdg::generic::c::surfaceIntegralNonlinear<NumberOfVariables, Order+1>(lduh,lFhbnd_g,&cellSize[0]);
{% endif %}
  
  delete[] lFhbnd_g;
    
} else {

  {{optNamespace}}::surfaceIntegral( lduh, lFhbnd, inverseDx );
  
}
{% if enableProfiler %}
  _profiler->stop("surfaceIntegral");
{% endif %}
}



void {{project}}::{{abstractSolver}}::riemannSolver(double* const FL,double* const FR,const double* const QL,const double* const QR,const double t,const double dt,const int direction,bool isBoundaryFace, int faceIndex) {
  assertion2(direction>=0,dt,direction);
  assertion2(direction<DIMENSIONS,dt,direction);
{% if enableProfiler %}
  _profiler->start("riemannSolver");
{% endif %}

constexpr bool useGeneric = false;
  
if(useGeneric) {
  
  double* FL_g = new double[{{optNamespace}}::converter::getFFaceGenArraySize()];
  double* FR_g = new double[{{optNamespace}}::converter::getFFaceGenArraySize()];
  double* QL_g = new double[{{optNamespace}}::converter::getQFaceGenArraySize()];
  double* QR_g = new double[{{optNamespace}}::converter::getQFaceGenArraySize()];

  {{optNamespace}}::converter::FFace_optimised2generic(FL,FL_g);
  {{optNamespace}}::converter::FFace_optimised2generic(FR,FR_g);
  {{optNamespace}}::converter::QFace_optimised2generic(QL,QL_g);
  {{optNamespace}}::converter::QFace_optimised2generic(QR,QR_g);
{% if isLinear %}
  kernels::aderdg::generic::c::riemannSolverLinear<{{useFlux_s}},{{useNCP_s}},{{useMaterialParameters_s}},{{solver}}>(*static_cast<{{solver}}*>(this),FL_g,FR_g,QL_g,QR_g,t,dt,direction);
{% else %}
  kernels::aderdg::generic::c::riemannSolverNonlinear<{{useNCP_s}},{{solver}}>(*static_cast<{{solver}}*>(this),FL_g,FR_g,QL_g,QR_g,t,dt,direction);
{% endif %}
  
  {{optNamespace}}::converter::FFace_generic2optimised(FL_g,FL);
  {{optNamespace}}::converter::FFace_generic2optimised(FR_g,FR);

  delete[] FL_g;  
  delete[] FR_g;  
  delete[] QL_g;  
  delete[] QR_g;
    
} else {

  {{optNamespace}}::riemannSolver(*static_cast<{{solver}}*>(this), FL, FR, QL, QR, t, dt, direction);
  
}
{% if enableProfiler %}
  _profiler->stop("riemannSolver");
{% endif %}
}



void {{project}}::{{abstractSolver}}::boundaryConditions(double* const fluxOut,double* const stateOut,const double* const fluxIn,const double* const stateIn,const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int faceIndex,const int direction) {
{% if enableProfiler %}
  _profiler->start("boundaryConditions");
{% endif %}
  {{optNamespace}}::boundaryConditions(*static_cast<{{solver}}*>(this), fluxOut, stateOut, fluxIn, stateIn, cellCentre, cellSize, t, dt, faceIndex, direction );
{% if enableProfiler %}
  _profiler->stop("boundaryConditions");
{% endif %}
}



double {{project}}::{{abstractSolver}}::stableTimeStepSize(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& inverseDx) {
{% if enableProfiler %}
  _profiler->start("stableTimeStepSize");
{% endif %}
  double d = {{optNamespace}}::stableTimeStepSize(*static_cast<{{solver}}*>(this), luh, inverseDx );
{% if enableProfiler %}
  _profiler->stop("stableTimeStepSize");
{% endif %}
  return d;
}



{% if !patchwiseAdjust %}
void {{project}}::{{abstractSolver}}::adjustSolution(double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,double dt) {
{% if enableProfiler %}
  _profiler->start("solutionAdjustment");
{% endif %}
  {{optNamespace}}::solutionAdjustment(*static_cast<{{solver}}*>(this), luh, cellCentre, cellSize, t, dt );
{% if enableProfiler %}
  _profiler->stop("solutionAdjustment");
{% endif %}
}
{% endif %}


void {{project}}::{{abstractSolver}}::deltaDistribution(const double t,const double dt, const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize, double** const tempPointForceSources) {
{% if usePointSources %}
{% if enableProfiler %}
  _profiler->start("deltaDistribution");
{% endif %}
  constexpr bool useGeneric = false;
  
  if(useGeneric) {
    double** tmp = new double*[2];
    tmp[0] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
    tmp[1] = new double[{{optNamespace}}::converter::getPSiGenArraySize()];
    kernels::aderdg::generic::c::deltaDistribution<{{solver}}>(*static_cast<{{solver}}*>(this), t, dt, cellCentre, cellSize,getNodesPerCoordinateAxis(), tmp);
    
    {{optNamespace}}::converter::PSi_generic2optimised(tmp[0],tempPointForceSources[0]);
    
    delete[] tmp[0];
    delete[] tmp[1];
    delete[] tmp;
  } else {
    {{optNamespace}}::deltaDistribution(*static_cast<{{solver}}*>(this), t, dt, cellCentre, cellSize, tempPointForceSources);
  }
{% if enableProfiler %}
  _profiler->stop("deltaDistribution");
{% endif %}
{% else %}
  //Point sources aren't defined, this method should be empty
{% endif %}
}


void {{project}}::{{abstractSolver}}::faceUnknownsProlongation(double* const lQhbndFine,double* const lFhbndFine,const double* const lQhbndCoarse,const double* const lFhbndCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{% if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
{% endif %}
  {{optNamespace}}::faceUnknownsProlongation( lQhbndFine, lFhbndFine, lQhbndCoarse, lFhbndCoarse, coarseGridLevel, fineGridLevel, subfaceIndex);
{% if enableProfiler %}
  _profiler->start("faceUnknownsProlongation");
{% endif %}
}



void {{project}}::{{abstractSolver}}::faceUnknownsRestriction(double* const lQhbndCoarse,double* const lFhbndCoarse,const double* const lQhbndFine,const double* const lFhbndFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS-1,int>& subfaceIndex) {
{% if enableProfiler %}
  _profiler->start("faceUnknownsRestriction");
{% endif %}
  {{optNamespace}}::faceUnknownsRestriction( lQhbndCoarse, lFhbndCoarse, lQhbndFine, lFhbndFine, coarseGridLevel, fineGridLevel, subfaceIndex);
{% if enableProfiler %}
  _profiler->stop("faceUnknownsRestriction");
{% endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsProlongation(double* const luhFine,const double* const luhCoarse,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{% if enableProfiler %}
  _profiler->start("volumeUnknownsProlongation");
{% endif %}
  {{optNamespace}}::volumeUnknownsProlongation( luhFine, luhCoarse, coarseGridLevel, fineGridLevel, subcellIndex);
{% if enableProfiler %}
  _profiler->stop("volumeUnknownsProlongation");
{% endif %}
}



void {{project}}::{{abstractSolver}}::volumeUnknownsRestriction(double* const luhCoarse,const double* const luhFine,const int coarseGridLevel,const int fineGridLevel,const tarch::la::Vector<DIMENSIONS,int>& subcellIndex) {
{% if enableProfiler %}
  _profiler->start("volumeUnknownsRestriction");
{% endif %}
  {{optNamespace}}::volumeUnknownsRestriction( luhCoarse, luhFine, coarseGridLevel, fineGridLevel, subcellIndex);
{% if enableProfiler %}
  _profiler->stop("volumeUnknownsRestriction");
{% endif %}
}

//--------

void {{project}}::{{abstractSolver}}::abortWithMsg(const char* const msg) {
	// verbosily fail even without assertions turned on
	puts(msg);
	abort();
}

void {{project}}::{{abstractSolver}}::flux(const double* const Q,double** const F) {
  abortWithMsg("If this operation is entered (flux), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::algebraicSource(const double* const Q,double* const S) {
  abortWithMsg("If this operation is entered (algebraicSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
        
void {{project}}::{{abstractSolver}}::nonConservativeProduct(const double* const Q,const double* const gradQ,double* const BgradQ) {
  abortWithMsg("If this operation is entered (nonConservativeProduct), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}

void {{project}}::{{abstractSolver}}::pointSource(const double* const x,const double t,const double dt, double* const forceVector, double* const x0, int n) {
  abortWithMsg("If this operation is entered (pointSource), you have activated the corresponding guard. Then you have to re-implement this routine, too." );
}
