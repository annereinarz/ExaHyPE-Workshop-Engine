// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __{{solver}}_Variables_CLASS_HEADER__
#define __{{solver}}_Variables_CLASS_HEADER__

#include "{{abstractSolver}}.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct {{project}}::{{abstractSolver}}::VariableMetrics {
  static constexpr int numDistinctVariables = {{variablesMapSize}};
  static constexpr int SizeVariables  = {{numberOfVariables}}; 
  static constexpr int SizeParameters = {{numberOfMaterialParameters}};
  static constexpr int Size           = {{numberOfVariables}}+{{numberOfMaterialParameters}};
  static constexpr int Dimensions     = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class {{project}}::{{abstractSolver}}::VariableShortcuts : public {{project}}::{{abstractSolver}}::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
{% set comma=joiner(",") %}
  const int _Q[numDistinctVariables + 1] = { {% for var in variablesMap %}{{ comma() }}{{var.offset}}{% endfor %} };

{% for var in variablesMap %}
  const int {{var.name}} = {{var.offset}};
{% endfor %}

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class {{project}}::{{abstractSolver}}::VariableMultiplicities : public {{project}}::{{abstractSolver}}::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
{% set comma=joiner(",") %} 
  const int _Q[numDistinctVariables] = { {% for var in variablesMap %}{{ comma() }}{{var.multiplicity}}{% endfor %} };

{% for var in variablesMap %}
  const int {{var.name}} = {{var.multiplicity}};
{% endfor %}

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class {{project}}::{{abstractSolver}}::VariableNames : public {{project}}::{{abstractSolver}}::VariableMetrics {
public:
{% set comma=joiner(",") %}
  char const *_Q[numDistinctVariables + 1] = { {% for var in variablesMap %}{{ comma() }}"{{var.name}}"{% endfor %} };

{% for var in variablesMap %}
  const char* {{var.name}} = "{{var.name}}";
{% endfor %}

  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace {{project}}::{{solver}}_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       {{project}}::{{abstractSolver}}::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace {{project}} {
  namespace {{solver}}_Variables {
    namespace shortcuts {
{% for var in variablesMap %}
      constexpr int {{var.name}} = {{var.offset}};
{% endfor %}
    } // namespace shortcuts
    namespace names {
{% for var in variablesMap %}
      constexpr char {{var.name}}[] = "{{var.name}}"; 
{% endfor %}
    } // namespace names
  } // end of namespace {{project}}::{{solver}}_Variables 
} // end of namespace {{project}}

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double* const Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class {{project}}::{{abstractSolver}}::ReadOnlyVariables : public {{project}}::{{abstractSolver}}::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

{% for var in variablesMap %}
{% if var.multiplicity == 1%}
    // getter and setter for {{var.name}}
    double {{var.name}}() const {return _Q[{{var.offset}}];}
        
{% else %}
    // getters for {{var.name}} 
    double {{var.name}}(int index) const {
      assertion(index >= 0 && index<{{var.multiplicity}});
      return _Q[{{var.offset}}+index];
    }
    tarch::la::Vector<{{var.multiplicity}},double> {{var.name}}() const {
      tarch::la::Vector<{{var.multiplicity}},double> values;
{% set comma=joiner(",") %}
      values={%for i in range(var.multiplicity)%}{{comma()}}_Q[{{var.offset+i}}]{%endfor%};
      return values;
    }
        
{% endif %}
{% endfor %}
}; // end of ReadOnlyVariables


class {{project}}::{{abstractSolver}}::Variables : public {{project}}::{{abstractSolver}}::VariableMetrics{
  private:
    double* _Q;
  public:
    static constexpr int SizeVariables  = {{numberOfVariables}};
    static constexpr int SizeParameters = {{numberOfMaterialParameters}};
    static constexpr int Size           = {{numberOfVariables}}+{{numberOfMaterialParameters}};
  
    Variables(double* const Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

{% for var in variablesMap %}
{% if var.multiplicity == 1%}
    // getter and setter for {{var.name}}
    double {{var.name}}() const {return _Q[{{var.offset}}];}
    double& {{var.name}}() {return _Q[{{var.offset}}];}
    
{% else %}
    // getters for {{var.name}} 
    double {{var.name}}(int index) const {
      assertion(index >= 0 && index<{{var.multiplicity}});
      return _Q[{{var.offset}}+index];
    }
    tarch::la::Vector<{{var.multiplicity}},double> {{var.name}}() const {
      tarch::la::Vector<{{var.multiplicity}},double> values;
      values={%for i in range(var.multiplicity - 1)%}_Q[{{var.offset+i}}],{%endfor%}_Q[{{var.offset+var.multiplicity-1}}];
      return values;
    }
    // setters for {{var.name}}
    double& {{var.name}}(int index) {return _Q[{{var.offset}}+index];}
    void {{var.name}}(const tarch::la::Vector<{{var.multiplicity}},double>& values) const {
{%for i in range(var.multiplicity)%}
      _Q[{{var.offset+i}}] = values[{{i}}];
{%endfor%}
    }
{% set comma = joiner(",") %}
    void {{var.name}}({%for i in range(var.multiplicity)%}{{comma()}}double {{var.name}}{{i}}{%endfor%}) {
{%for i in range(var.multiplicity)%}
      _Q[{{var.offset+i}}] = {{var.name}}{{i}};
{%endfor%}
    }
    
{% endif %}
{% endfor %}
}; // end of Variables


class {{project}}::{{abstractSolver}}::Fluxes : public {{project}}::{{abstractSolver}}::VariableMetrics {
  private:
    double** _F;
  public:
    Fluxes(double** const F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


{% for var in variablesMap %}
    // getters for {{var.name}}
{% if var.multiplicity==1 %}
{# ex: double rho(int column) const;  #}
    double {{var.name}}(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][{{var.offset}}];
    }
{# ex: tarch::la::Vector<DIMENSIONS,double> rho() const; #}
    tarch::la::Vector<DIMENSIONS,double> {{var.name}}() const {
      #if DIMENSIONS==2 
{% set comma=joiner(",") %}
      tarch::la::Vector<DIMENSIONS,double> values({% for i in range(2) %}{{ comma() }}_F[{{i}}][{{var.offset}}]{% endfor %});
      #elif DIMENSIONS==3 
{% set comma=joiner(",") %}
      tarch::la::Vector<DIMENSIONS,double> values({% for i in range(3) %}{{ comma() }}_F[{{i}}][{{var.offset}}]{% endfor %});
      #endif
      return values;
    }
{% else %}
{# ex: double v(int row, int column) const; #}
    double {{var.name}}(int row, int column) const {
      assertion(row >= 0 && row<{{var.multiplicity}});
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][{{var.offset}}+row];
    }
{# ex: tarch::la::Vector<3,double> v(int row) const; #}
    tarch::la::Vector<DIMENSIONS,double> {{var.name}}(int row) const {
      assertion(row >= 0 && row<{{var.multiplicity}});
      #if DIMENSIONS==2
{% set comma=joiner(",") %}
      tarch::la::Vector<DIMENSIONS,double> values({% for i in range(2) %}{{ comma() }}_F[{{i}}][{{var.offset}}+row]{% endfor %});
      #elif DIMENSIONS==3 
{% set comma=joiner(",") %}
      tarch::la::Vector<DIMENSIONS,double> values({% for i in range(3) %}{{ comma() }}_F[{{i}}][{{var.offset}}+row]{% endfor %});
      #endif
      return values;
    }
{# ex: tarch::la::Matrix<3,3,double> v() const; #}
    tarch::la::Matrix<{{var.multiplicity}},DIMENSIONS,double> {{var.name}}() const {
      tarch::la::Matrix<{{var.multiplicity}},DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
{% set newline = joiner(",\n") %}
      {% for i in range(var.multiplicity) %}{{ newline() }}{% set comma=joiner(",") %}
      {% for j in range(2) %}{{ comma() }}_F[{{j}}][{{var.offset}}+{{i}}]{% endfor %}
      {% endfor %};
      #elif DIMENSIONS==3
      values = 
{% set newline = joiner(",\n") %}
      {% for i in range(var.multiplicity) %}{{ newline() }}{% set comma=joiner(",") %}
      {% for j in range(3) %}{{ comma() }}_F[{{j}}][{{var.offset}}+{{i}}]{% endfor %}{% endfor %};
      #endif
      return values;
    }
{% endif %}
    // setters for {{var.name}}
{% if var.multiplicity==1 %}
    {# ex: double& v(int column); #}
    double& {{var.name}}(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][{{var.offset}}];
    }

    {# ex: void rho(tarch::la::Vector<DIMENSIONS,double>& values); 3D and 2D #}
    void {{var.name}}(const tarch::la::Vector<DIMENSIONS,double>& values) {
      {% for j in range(2) %}
      _F[{{j}}][{{var.offset}}] = values[{{j}}];
      {% endfor %}
      #if DIMENSIONS==3
      _F[2][{{var.offset}}] = values[2];
      #endif
    }

    {# ex: void rho(tarch::la::Vector<DIMENSIONS,double>& values); 2.5D #}
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void {{var.name}}(const tarch::la::Vector<3,double>& values) {
      {% for j in range(2) %}
      _F[{{j}}][{{var.offset}}] = values[{{j}}];
      {% endfor %}
    }
    #endif

    {# ex: void v(double v0, double v1, double v2);  3D and 2.5D #}
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    {% set comma=joiner(",") %}
    void {{var.name}}({% for j in range(3) %}{{comma()}}double v{{j}}{% endfor %}) {
      {% for j in range(2) %}
      _F[{{j}}][{{var.offset}}] = v{{j}};
      {% endfor %}
      #if DIMENSIONS==3
      _F[2][{{var.offset}}] = v2;
      #endif
    }
    
    {# ex: void v(double v0, double v1); 2D #}
    #if DIMENSIONS==2
    {% set comma=joiner(",") %}
    void {{var.name}}({% for j in range(2) %}{{comma()}}double v{{j}}{% endfor %}) {
    {% for j in range(2) %}
      _F[{{j}}][{{var.offset}}] = v{{j}};
    {% endfor %}
    }
    #endif
{# multiplicity > 1 #}
{% else %}
    {# ex: double& v(int row, int column) #}
    double& {{var.name}}(int row, int column) {
      assertion(row >= 0 && row<{{var.multiplicity}});
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][{{var.offset}}+row];
    }

    {# ex: void v(int row, const tarch::la::Vector<3,double>& values); 2D and 3D
    void {{var.name}}(int row, const tarch::la::Vector<DIMENSIONS,double>& values) {
      assertion(row >= 0 && row<{{var.multiplicity}});
      {% for j in range(2) %}
      _F[{{j}}][{{var.offset}}+row] = values[{{j}}];
      {% endfor %}
      #if DIMENSIONS==3
      _F[2][{{var.offset}}+row] = values[2];
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void {{var.name}}(int row, const tarch::la::Vector<3,double>& values) {
      assertion(row >= 0 && row<{{var.multiplicity}});
        {% for j in range(2) %}
       _F[{{j}}][{{var.offset}}+row] = values[{{j}}];
       {% endfor %}
    }
    #endif
      
    {# ex: void v(const tarch::la::Matrix<3,DIMENSIONS,double>& values);  2D and 3D #}
    void {{var.name}}(const tarch::la::Matrix<{{var.multiplicity}},DIMENSIONS,double>& values) {
      {% for j in range(2) %}
      {% for i in range(var.multiplicity) %}
      _F[{{j}}][{{var.offset}}+{{i}}] = values({{i}},{{j}});
      {% endfor %}
      {% endfor %}
      #if DIMENSIONS==3
      {% for i in range(var.multiplicity) %}
      _F[2][{{var.offset}}+{{i}}] = values({{i}},2);
      {% endfor %}
      #endif
    }
    {# ex: void v(const tarch::la::Matrix<3,3,double>& values);  2.5D #}
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void {{var.name}}(const tarch::la::Matrix<{{var.multiplicity}},3,double>& values) {
      {% for j in range(2) %}
      {% for i in range(var.multiplicity) %}
      _F[{{j}}][{{var.offset}}+{{i}}] = values({{i}},{{j}});
      {% endfor %}
      {% endfor %}
    }
    #endif
      
{# ex: void v(int row, double v0, double v1, double v2); #}
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
{% set comma = joiner(",") %}
    void {{var.name}}(int row, {% for j in range(3) %}{{comma()}}double v{{j}}{% endfor %}) {
      assertion(row >= 0 && row<{{var.multiplicity}});
{% for j in range(2) %}
      _F[{{j}}][{{var.offset}}+row] = v{{j}};
{% endfor %}
      #if DIMENSIONS==3
      _F[2][{{var.offset}}+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
{% set comma = joiner(",") %}
    void {{var.name}}(int row, {% for j in range(2) %}{{comma()}}double v{{j}}{% endfor %}) {
      assertion(row >= 0 && row<{{var.multiplicity}});
{% for j in range(2) %}
      _F[{{j}}][{{var.offset}}+row] = v{{j}};
{% endfor %}
    }
    #endif

{# ex: void v(double v00, double v01, double v02, double v10, double v11, double v12, double v20, double v21, double v22);  2.5D and 3D #}
    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    {% set comma = joiner(",") %}
    void {{var.name}}({% for i in range(var.multiplicity) %}{% for j in range(3) %}{{comma()}}double v{{i}}{{j}}{% endfor %}{% endfor %}) {
      {% for j in range(2) %}
      {% for i in range(var.multiplicity) %}
      _F[{{j}}][{{var.offset}}+{{i}}] = v{{i}}{{j}};
      {% endfor %}
      {% endfor %}
      #if DIMENSIONS==3
      {% for i in range(var.multiplicity) %}
      _F[2][{{var.offset}}+{{i}}] = v{{i}}2;
      {% endfor %}
      #endif
    }
    {# ex: void v(double v00, double v01, double v02, double v10, double v11, double v12, double v20, double v21, double v22);  2D #}
    #if DIMENSIONS==2
    {% set comma = joiner(",") %}
    void {{var.name}}({% for i in range(var.multiplicity) %}{% for j in range(2) %}{{comma()}}double v{{i}}{{j}}{% endfor %}{% endfor %}) {
      {% for j in range(2) %}
      {% for i in range(var.multiplicity) %}
      _F[{{j}}][{{var.offset}}+{{i}}] = v{{i}}{{j}};
      {% endfor %}
      {% endfor %}
    }
    #endif
{% endif %}
{% endfor %}
}; // end of Fluxes

// NamingSchemes:
{% for name in namingSchemes.keys() %}
class {{project}}::{{abstractSolver}}::{{name | capitalize}} {
  private:
    double _data[{{totalsize}}];
  public:
    static constexpr int Size = {{totalsize}};
    
    {{name | capitalize}}() {}
    
    
    void operator = ({{name | capitalize}}& value) {
      std::copy(value.data(),value.data()+Size,_data);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _data[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _data[index];
    }
    
    double* data() {
      return _data;
    }
    
    int size() const {
      return Size;
    }
    

//Getter
{% for id in namingSchemes.name.keys() %}
{% set multiplicity = namingSchemes.name.id %}
{% if multiplicity == 1%}
    double {{id}}() const {return _data[{{var.offset}}];}
{% else %}
    double {{id}}(int index) const {
      assertion(index >= 0 && index<{{multiplicity}});
      return _data[{{var.offset}}+index];
    }
    tarch::la::Vector<{{multiplicity}},double> {{id}}() const {
      tarch::la::Vector<{{multiplicity}},double> values;
      values={%for i in range(var.multiplicity)%}_data[{{var.offset+i}}],{%endfor%}_data[{{var.offset+multiplicity-1}}];
      return values;
    }
{% endif %}
{% endfor %}
//Setter
{% for id in namingSchemes.name.keys() %}
{% set multiplicity = namingSchemes.name.id %}
{% if multiplicity == 1%}
    double& {{id}}() const {return _data[{{var.offset}}];}
{% else %}
    double& {{id}}(int index) const {return _data[{{var.offset}}+index];}
    void {{id}}(const tarch::la::Vector<{{multiplicity}},double>& values)) const {
{% for i in range(var.multiplicity) %}
      _data[{{var.offset+i}}] = values[{{i}}];
{% endfor %}
    }
    void {{id}}({%for i in range(var.multiplicity)%}double {{id}}{{i}},{%endfor%}double {{id}}{{multiplicity-1}}) {
{% for i in range(var.multiplicity) %}
      _data[{{var.offset+i}}] = {{id}}{{i}};
{% endfor %}
    }
{% endif %}
{% endfor %}
};
{% endfor %}

#endif
